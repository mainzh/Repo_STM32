串口通信，最基础的收发模式有：轮询（阻塞）、中断、DMA这三种，是所有扩展模式的基础

| 模式 | 核心原理                   | 优点                  | 缺点                   | 适用场景                 |
| ---- | -------------------------- | --------------------- | ---------------------- | ------------------------ |
| 轮询 | CPU 阻塞轮询状态位         | 代码简单、无中断依赖  | 占用 CPU、实时性差     | 小数据、低频率、调试场景 |
| 中断 | 硬件触发中断，CPU 按需处理 | 实时性高、CPU 占用低  | 频繁中断可能影响系统   | 中小数据、高实时性场景   |
| DMA  | 硬件直接搬运数据（无 CPU） | 极低 CPU 占用、高吞吐 | 配置稍复杂、需处理回调 | 大数据、高频收发场景     |

# 轮询模式



# 中断模式

## 核心原理

UART 中断模式的核心是：**硬件检测到特定事件（如接收字节、发送完成）时触发中断，CPU 在中断回调中处理数据**，无需轮询。

- 接收中断：触发条件是「接收寄存器非空（RXNE）」，即收到 1 个字节就触发；
- 发送中断：触发条件是「发送完成（TC）」，即 1 个字节发送完毕就触发；
- 关键特点：HAL 库的中断接口（`HAL_UART_Receive_IT`/`HAL_UART_Transmit_IT`）是**单次触发**，回调执行后需重新开启中断才能继续收发。

## 使用示例

「固定长度收发」和「不定长接收（环形缓冲区）」两种常用场景（后者更贴近实际项目）。

### 1.基础配置 (CubeMX)

先完成硬件初始化（CubeMX 生成代码）：

- UART：开启 USART1，配置波特率（如 115200）、8N1，开启「NVIC 中断」（勾选 USART1 global interrupt）；
- 无需配置 DMA（中断模式不依赖 DMA）。

### 2.代码实现

```c
#include "stm32f4xx_hal.h"

/* 全局变量定义 */
#define UART_RX_BUF_SIZE 64    // 环形缓冲区大小
#define UART_TX_BUF_SIZE 64    // 发送缓冲区大小

// 接收：环形缓冲区（解决中断模式不定长接收问题）
uint8_t uart1_rx_buf[UART_RX_BUF_SIZE];  // 接收缓冲区
uint16_t uart1_rx_head = 0;              // 缓冲区读指针
uint16_t uart1_rx_tail = 0;              // 缓冲区写指针
uint8_t uart1_rx_temp;                   // 中断接收临时字节（关键！）

// 发送：临时缓冲区（避免中断中直接操作大数组）
uint8_t uart1_tx_buf[UART_TX_BUF_SIZE];
uint16_t uart1_tx_len = 0;
uint8_t uart1_tx_busy = 0;               // 发送忙标志（避免重复触发）

UART_HandleTypeDef huart1;               // UART句柄（CubeMX生成）

/* ==================== 接收中断相关函数 ==================== */
// 步骤1：开启UART1接收中断（单次，接收1个字节）
void UART1_Start_Receive_IT(void)
{
    // 开启中断接收：接收1个字节到临时变量uart1_rx_temp
    if (HAL_UART_Receive_IT(&huart1, &uart1_rx_temp, 1) != HAL_OK)
    {
        // 开启失败处理（可选）
        Error_Handler();
    }
}

// 步骤2：重写接收完成回调（收到1个字节就触发）
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
    {
        // 1. 将接收的字节存入环形缓冲区
        uint16_t next_tail = (uart1_rx_tail + 1) % UART_RX_BUF_SIZE;
        if (next_tail != uart1_rx_head)  // 缓冲区未满
        {
            uart1_rx_buf[uart1_rx_tail] = uart1_rx_temp;
            uart1_rx_tail = next_tail;
        }
        // 2. 重新开启接收中断（核心！单次中断需重启）
        UART1_Start_Receive_IT();
    }
}

// 步骤3：环形缓冲区读取函数（主循环中调用，获取接收的数据）
uint16_t UART1_Read_Rx_Buf(uint8_t *buf, uint16_t len)
{
    uint16_t read_len = 0;
    // 关中断（避免读写指针冲突）
    __disable_irq();
    while (uart1_rx_head != uart1_rx_tail && read_len < len)
    {
        buf[read_len++] = uart1_rx_buf[uart1_rx_head];
        uart1_rx_head = (uart1_rx_head + 1) % UART_RX_BUF_SIZE;
    }
    // 开中断
    __enable_irq();
    return read_len;
}

/* ==================== 发送中断相关函数 ==================== */
// 步骤1：开启UART1发送中断（封装，避免重复发送）
uint8_t UART1_Start_Transmit_IT(uint8_t *buf, uint16_t len)
{
    if (uart1_tx_busy || len == 0 || len > UART_TX_BUF_SIZE)
    {
        return 0;  // 忙/空/超长，发送失败
    }
    // 1. 标记发送中
    uart1_tx_busy = 1;
    // 2. 拷贝数据到发送缓冲区
    memcpy(uart1_tx_buf, buf, len);
    uart1_tx_len = len;
    // 3. 开启中断发送
    if (HAL_UART_Transmit_IT(&huart1, uart1_tx_buf, uart1_tx_len) != HAL_OK)
    {
        uart1_tx_busy = 0;
        return 0;
    }
    return 1;
}

// 步骤2：重写发送完成回调
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
    {
        // 标记发送完成
        uart1_tx_busy = 0;
        // 可选：发送完成后的逻辑（如触发下一次发送）
    }
}

/* ==================== 错误处理回调 ==================== */
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
    {
        // 发生错误（如帧错误、溢出），重启接收中断
        UART1_Start_Receive_IT();
        // 可选：清除错误标志
        __HAL_UART_CLEAR_OREFLAG(&huart1);
        __HAL_UART_CLEAR_FEFLAG(&huart1);
    }
}

/* ==================== 主函数调用示例 ==================== */
int main(void)
{
    // 1. 硬件初始化（CubeMX生成）
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_USART1_UART_Init();
    
    // 2. 开启接收中断（程序启动后立即监听串口）
    UART1_Start_Receive_IT();
    
    // 3. 主循环
    uint8_t rx_data[32];
    uint16_t rx_len;
    while (1)
    {
        // === 接收处理：从环形缓冲区读取数据 ===
        rx_len = UART1_Read_Rx_Buf(rx_data, sizeof(rx_data));
        if (rx_len > 0)
        {
            // 示例：收到数据后回显（用中断发送）
            UART1_Start_Transmit_IT(rx_data, rx_len);
            
            // 可选：解析数据（如判断是否为指令）
            // if (rx_data[0] == 'A') { ... }
        }
        
        // === 其他业务逻辑 ===
        HAL_Delay(10);
    }
}

// CubeMX生成的错误处理函数（保留）
void Error_Handler(void)
{
    __disable_irq();
    while (1)
    {
    }
}

```



# DMA模式



# `printf`重定向

将`printf`重定向为**基于 “环形缓冲区 + DMA / 中断模式” 的非阻塞版本**：无论在主循环还是中断中调用`printf`，都仅完成缓冲区写入（微秒级完成），发送逻辑由硬件中断（DMA 完成）自动触发，完全避免阻塞。

1. 在`fputc`（非中断上下文）和 DMA 发送完成回调中，**自动触发缓冲区发送检查**；
2. 保留环形缓冲区的线程安全保护，确保中断 / 主循环写入不冲突；
3. 避免在中断上下文直接触发 DMA 发送（仅修改指针），仅在非中断上下文触发发送。

代码实现

```c
#include "stm32f4xx_hal.h"
#include <stdio.h>
#include <string.h>

/* ==================== 非阻塞printf核心配置 ==================== */
#define PRINTF_BUF_SIZE 256  // 打印缓冲区大小（根据需求调整）
uint8_t printf_buf[PRINTF_BUF_SIZE];  // 环形缓冲区
uint16_t printf_buf_head = 0;         // 读指针（DMA发送用）
uint16_t printf_buf_tail = 0;         // 写指针（中断/主循环写用）
uint8_t uart_tx_busy = 0;             // 串口发送忙标志
UART_HandleTypeDef huart1;            // UART句柄（CubeMX生成）
uint8_t uart1_rx_temp = 0;            // 接收临时变量（补充定义）

/* 私有函数声明：缓冲区发送检查（内部调用） */
static void printf_buf_try_send(void);

/* 1. 环形缓冲区写入函数（中断中可安全调用） */
static uint16_t printf_buf_write(uint8_t *data, uint16_t len)
{
    uint16_t write_len = 0;
    // 关中断保护（避免读写指针冲突，中断中调用时也需关）
    __disable_irq();
    while (len > 0)
    {
        uint16_t next_tail = (printf_buf_tail + 1) % PRINTF_BUF_SIZE;
        if (next_tail == printf_buf_head) break;  // 缓冲区满，退出
        
        printf_buf[printf_buf_tail] = *data++;
        printf_buf_tail = next_tail;
        write_len++;
        len--;
    }
    __enable_irq();
    return write_len;
}

/* 2. 串口DMA发送完成回调：自动触发下一次发送 */
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
    {
        // 判断是否为DMA模式：hdmatx不为NULL 且 DMA通道未就绪
        if (huart->hdmatx != NULL && huart->hdmatx->State != HAL_DMA_STATE_READY)/* USART1 DMA发送完成 */
        {
            uart_tx_busy = 0;  // 发送完成，清除忙标志
            printf_buf_try_send();  // 自动检查并发送下一批数据
        }
        else    /* USART1 中断发送完成 */
        {
            
        }
    }
}

/* 3. 缓冲区发送检查（核心：自动触发DMA发送，无需主循环调用） */
static void printf_buf_try_send(void)
{
    if (uart_tx_busy) return;  // 发送中，跳过
    
    // 计算待发送长度（关中断保护指针）
    uint16_t len = 0;
    __disable_irq();
    if (printf_buf_head != printf_buf_tail)
    {
        len = (printf_buf_tail - printf_buf_head + PRINTF_BUF_SIZE) % PRINTF_BUF_SIZE;
        // 限制单次发送长度（避免DMA传输过长，适配F4的DMA最大传输长度）
        if (len > 64) len = 64;
    }
    __enable_irq();
    
    // 开启DMA发送
    if (len > 0)
    {
        uart_tx_busy = 1;
        // 检查DMA状态，避免重复启动（增强鲁棒性）
        if (HAL_UART_Transmit_DMA(&huart1, &printf_buf[printf_buf_head], len) == HAL_OK)
        {
            // 更新读指针（仅在DMA启动成功后更新）
            __disable_irq();
            printf_buf_head = (printf_buf_head + len) % PRINTF_BUF_SIZE;
            __enable_irq();
        }
        else
        {
            uart_tx_busy = 0;  // DMA启动失败，重置忙标志
        }
    }
}

/* 4. 重定向printf（替换默认的fputc） */
int fputc(int ch, FILE *f)
{
    // 仅处理串口输出（忽略其他流）
    if (f == stdout || f == stderr)
    {
        // 中断中调用时，仅写入缓冲区；非中断时，写入后自动尝试发送
        uint32_t is_in_irq = __get_PRIMASK();  // 判断是否在中断上下文（PRIMASK=1表示关中断/在中断）
        printf_buf_write((uint8_t*)&ch, 1);
        
        // 非中断上下文：立即尝试发送（避免数据堆积）
        if (is_in_irq == 0)
        {
            printf_buf_try_send();
        }
    }
    return ch;
}

```

